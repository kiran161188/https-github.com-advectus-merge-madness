# # Generic script to merge from a branch to any branch
####Require for locking/unlocking script
require "net/http"
require "uri"

# #### Usage:
#   path/to/ruby merge_to_from.rb absolute_path_to_git_checkout to_branch_name from_branch_name
abort "usage: ruby merge_to_from.rb absolute_path_to_git_checkout to_branch_name from_branch_name" if ARGV.length < 3
# @param {String}   git_checkout   where things live in git
# @param {String}   to_branch      the name of the branch into which need to merge
# @param {String}   from_branch    the name of the branch which we need to merge to other branch
# @param {String}   create_date    Is set automatically by system time, used by @date para
@git_checkout = "#{ARGV[0]}" 
@to_branch = "#{ARGV[1]}" #BR_ACL_HOTFIX
@from_branch = "#{ARGV[2]}" #BR_git_P1_PSA_HOTFIXES
@date = Time.now.to_s.split(" ")[0].gsub("-","")
@checkfor= '"<< HEAD"'
# #### validate params before run through Script
puts "GIT location: #{@git_checkout}"
puts "To branch: #{@to_branch}"
puts "From branch: #{@from_branch}"
puts "Date: #{@date}"
puts "wwwin-git-sjc.cisco.com:/git/ecm/git.git/hooks\n\nLOCK: #{@from_branch}\n\nproceed to merge? "
# Hit enter to proceed or ctrl+c to exit from script after validating the values
proceed = STDIN.gets.chomp
# #### fetch udpates from remote for **from** and **to** branches
system("cd #{@git_checkout} && git fetch")
system("cd #{@git_checkout} && git checkout #{@from_branch}")
system("cd #{@git_checkout} && git pull origin #{@from_branch}")
system("cd #{@git_checkout} && git checkout #{@to_branch}")
system("cd #{@git_checkout} && git pull origin #{@to_branch}")
# #### validate the branches
system("cd #{@git_checkout} && git remote show origin")
# #### Hit enter to proceed or ctrl+c to exit from script after validating all the branches are upto date or not
puts "ensure everything is up to date, if not ctrl+c"
proceed = STDIN.gets.chomp
puts proceed.class
# #### Hit enter to proceed with merging of the **from** branch to **to** or ctrl+c to exit from script
puts "proceed with the merge from #{@from_branch} to #{@to_branch}"
proceed = STDIN.gets.chomp
# #### Checkout **to** branch
puts "merging #{@from_branch} to #{@to_branch}"
system("cd #{@git_checkout} && git checkout #{@to_branch}")
# #### Do Tag before merging **from** Branch to **to** branch
puts "tagging: TAG_BEFORE_MERGE_FROM_#{@from_branch}_TO_#{@to_branch}_#{@date} -m 'before merge from #{@from_branch} to #{@to_branch}'"
system("cd #{@git_checkout} && git tag -a TAG_BEFORE_MERGE_FROM_#{@from_branch}_TO_#{@to_branch}_#{@date} -m before_merge_from_#{@from_branch}_to_#{@to_branch}")
# #### Do merge from **from** Branch to **to** branch
system("cd #{@git_checkout} && git merge #{@from_branch} --no-commit --no-ff")
#system("cd #{@git_checkout} && git status")
system("cd #{@git_checkout} && git status -s > changes.txt")
system("cd #{@git_checkout} && cat changes.txt")
# ####  if there are any conflicts please resolve them before proceeding further
# #### if no conflicts proceed to git merge residual check, if not ctrl+c
puts "if no conflicts proceed to git merge residual check, if not ctrl+c"
proceed = STDIN.gets.chomp
# #### check the merge residuals
puts "git merge residuals:"
system("cd #{@git_checkout} && grep -r  #{@checkfor} *")
# #### if no files with git merge residuals proceed to smoke test? if so ctrl+c
puts "if no files with git merge residuals proceed to smoke test? if so ctrl+c"
proceed = STDIN.gets.chomp
# #### Sanity check/smoke test the merged code before commiting to the Git remote repository
system("cd #{@git_checkout} && mvn clean install")
system("cd #{@git_checkout} && mvn clean install -P buildSetup")
# #### check for your local CQ instance is up and running  , ready for deploy
puts "ready to deploy - is your local CQ running?"
proceed = STDIN.gets.chomp
system("cd #{@git_checkout} && mvn clean install -P buildCore,deployCore")
# #### check the results of the smoke test before proceeding to commit
puts "check the results of the smoke test before proceeding to commit\nwould you like to commit and set tag after merge?"
proceed = STDIN.gets.chomp
# #### Add all modified files and commit the changes
system("cd #{@git_checkout} && git add -A")
system("cd #{@git_checkout} && git commit -m merged_#{@from_branch}_to_#{@to_branch}")
# #### Do Tag After merging **from** Branch to **to** branch
puts "tagging: TAG_AFTER_MERGE_FROM_#{@from_branch}_TO_#{@to_branch}_#{@date} -m 'after merge from #{@from_branch} to #{@to_branch}'"
#system("cd #{@git_checkout} && git tag -a TAG_AFTER_MERGE_FROM_#{@from_branch}_TO_#{@to_branch}_#{@date} -m after_merge_from_#{@from_branch}_to_#{@to_branch}")
system("cd #{@git_checkout}&&git tag -a TAG_AFTER_MERGE_FROM_#{@from_branch}_TO_#{@to_branch}_#{@date} -F changes.txt")
system("cd #{@git_checkout} && git show --name-status HEAD^ HEAD TAG_AFTER_MERGE_FROM_#{@from_branch}_TO_#{@to_branch}_#{@date}")
##### Unlocking the branch with hookomator script
def lockpick(state,branch)
  puts "#{state}ing feature :#{branch}"
  uri = URI.parse("http://8080/job/hookomator/buildWithParameters")
  response = Net::HTTP.post_form(uri,{"action"=>"#{state}","branch"=>"#{branch}"})
  puts response
  end
lockpick("unlock",@to_branch)
# #### Hit enter to push the changes to remote repository or ctrl+c to exit from script
puts "proceed to push? ensure that #{@to_branch} branch is unlocked"
proceed = STDIN.gets.chomp
# #### PUSH all the Tags and the **to** branch to remote repository
system("cd #{@git_checkout} && git push origin #{@to_branch}")
system("cd #{@git_checkout} && git push origin TAG_BEFORE_MERGE_FROM_#{@from_branch}_TO_#{@to_branch}_#{@date}")
system("cd #{@git_checkout} && git push origin TAG_AFTER_MERGE_FROM_#{@from_branch}_TO_#{@to_branch}_#{@date}")

puts "all done"
